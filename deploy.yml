const axios = require('axios');
const crypto = require('crypto');
const fs = require('fs');
const FormData = require('form-data');

class Nanana {
    constructor() {
        this.baseUrl = 'https://nanana.app';
        this.tempMail = new TempMailScraper();
        this.sessionToken = '';
        this.cookieString = '';
        this.defaultHeaders = {
            'accept': '*/*',
            'accept-language': 'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7',
            'origin': this.baseUrl,
            'referer': `${this.baseUrl}/en`,
            'sec-ch-ua': '"Not:A-Brand";v="99", "Google Chrome";v="145", "Chromium";v="145"',
            'sec-ch-ua-mobile': '?0',
            'sec-ch-ua-platform': '"Windows"',
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/145.0.0.0 Safari/537.36'
        };
    }

    async initialize() {
        try {
            const email = await this.tempMail.getEmail();
            console.log(`Using email: ${email}`);
            
            await this.sendOtp(email);
            console.log('OTP sent successfully');
            
            const code = await this.tempMail.waitForCode();
            console.log(`Received OTP code: ${code}`);
            
            const verifyResult = await this.verifyOtp(email, code);
            console.log('Verification successful');
            
            return verifyResult;
        } catch (error) {
            console.error('Initialization failed:', error.message);
            throw error;
        }
    }

    async sendOtp(email) {
        try {
            const response = await axios.post(
                `${this.baseUrl}/api/auth/email-otp/send-verification-otp`,
                { email, type: 'sign-in' },
                { headers: this.defaultHeaders }
            );
            return response.data;
        } catch (error) {
            console.error('Send OTP failed:', error.response?.data || error.message);
            throw error;
        }
    }

    async verifyOtp(email, otp) {
        try {
            const response = await axios.post(
                `${this.baseUrl}/api/auth/sign-in/email-otp`,
                { email, otp },
                { 
                    headers: this.defaultHeaders, 
                    withCredentials: true,
                    maxRedirects: 0
                }
            );
            
            const setCookie = response.headers['set-cookie'];
            if (setCookie && setCookie.length > 0) {
                const sessionCookie = setCookie.find(c => c.includes('__Secure-better-auth.session_token'));
                if (sessionCookie) {
                    this.sessionToken = sessionCookie.split(';')[0];
                    this.cookieString = this.sessionToken;
                }
            }
            
            return response.data;
        } catch (error) {
            console.error('Verify OTP failed:', error.response?.data || error.message);
            throw error;
        }
    }

    async uploadImage(imagePath) {
        try {
            if (!fs.existsSync(imagePath)) {
                throw new Error(`Image file not found: ${imagePath}`);
            }

            const form = new FormData();
            form.append('image', fs.createReadStream(imagePath));

            const response = await axios.post(
                `${this.baseUrl}/api/upload-img`,
                form,
                {
                    headers: {
                        ...this.defaultHeaders,
                        ...form.getHeaders(),
                        'Cookie': this.cookieString,
                        'x-fp-id': this.generateFpId()
                    }
                }
            );

            return response.data;
        } catch (error) {
            console.error('Upload image failed:', error.response?.data || error.message);
            throw error;
        }
    }

    generateFpId() {
        const random = crypto.randomBytes(32).toString('hex');
        const timestamp = Date.now().toString();
        return Buffer.from(random + timestamp).toString('base64').slice(0, 128);
    }

    async generateImage(imageUrl, prompt) {
        try {
            const response = await axios.post(
                `${this.baseUrl}/api/image-to-image`,
                { prompt, image_urls: [imageUrl] },
                {
                    headers: {
                        ...this.defaultHeaders,
                        'content-type': 'application/json',
                        'Cookie': this.cookieString,
                        'x-fp-id': this.generateFpId()
                    }
                }
            );

            return response.data;
        } catch (error) {
            console.error('Generate image failed:', error.response?.data || error.message);
            throw error;
        }
    }

    async getResult(requestId) {
        try {
            const response = await axios.post(
                `${this.baseUrl}/api/get-result`,
                { requestId, type: 'image-to-image' },
                {
                    headers: {
                        ...this.defaultHeaders,
                        'content-type': 'application/json',
                        'Cookie': this.cookieString,
                        'x-fp-id': this.generateFpId()
                    }
                }
            );

            return response.data;
        } catch (error) {
            console.error('Get result failed:', error.response?.data || error.message);
            throw error;
        }
    }

    async processImage(imagePath, prompt, maxAttempts = 30) {
        try {
            console.log('Uploading image...');
            const uploadResult = await this.uploadImage(imagePath);
            console.log('Image uploaded:', uploadResult.url);
            
            console.log('Generating image with prompt:', prompt);
            const generateResult = await this.generateImage(uploadResult.url, prompt);
            console.log('Generation started, request ID:', generateResult.request_id);
            
            let attempts = 0;
            while (attempts < maxAttempts) {
                attempts++;
                console.log(`Checking result (attempt ${attempts}/${maxAttempts})...`);
                
                const result = await this.getResult(generateResult.request_id);
                
                if (result.completed) {
                    console.log('Process completed successfully!');
                    console.log(JSON.stringify(result, null, 2));
                    return result;
                }
                
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
            
            throw new Error('Max attempts reached without completion');
        } catch (error) {
            console.error('Process image failed:', error.message);
            throw error;
        }
    }
}

class TempMailScraper {
    constructor() {
        this.baseUrl = 'https://akunlama.com';
        this.headers = {
            'accept': 'application/json, text/plain, */*',
            'accept-language': 'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7',
            'referer': 'https://akunlama.com/',
            'sec-ch-ua': '"Not:A-Brand";v="99", "Google Chrome";v="145", "Chromium";v="145"',
            'sec-ch-ua-mobile': '?0',
            'sec-ch-ua-platform': '"Windows"',
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/145.0.0.0 Safari/537.36'
        };
        this.recipient = crypto.randomBytes(8).toString('hex').substring(0, 10);
        this.lastCount = 0;
        this.email = null;
    }

    async getEmail() {
        try {
            // Create email address
            this.email = `${this.recipient}@akunlama.com`;
            
            // Try to register/initialize the email
            const response = await axios.get(`${this.baseUrl}/api/create`, {
                params: { recipient: this.recipient },
                headers: this.headers
            });
            
            console.log('Email created successfully');
            return this.email;
        } catch (error) {
            console.error('Failed to create email:', error.message);
            // If creation fails, still return the email address
            return this.email || `${this.recipient}@akunlama.com`;
        }
    }

    async waitForCode(timeout = 120000) { // 2 minutes timeout
        return new Promise((resolve, reject) => {
            const startTime = Date.now();
            
            const interval = setInterval(async () => {
                try {
                    // Check timeout
                    if (Date.now() - startTime > timeout) {
                        clearInterval(interval);
                        reject(new Error('Timeout waiting for OTP code'));
                        return;
                    }

                    const inbox = await this.checkInbox();
                    
                    if (inbox && inbox.length > this.lastCount) {
                        for (const msg of inbox.slice(this.lastCount)) {
                            try {
                                const html = await this.getMessageContent(msg);
                                const code = this.extractCode(html);
                                
                                if (code) {
                                    clearInterval(interval);
                                    resolve(code);
                                    return;
                                }
                            } catch (msgError) {
                                console.error('Error processing message:', msgError.message);
                            }
                        }
                        this.lastCount = inbox.length;
                    }
                } catch (error) {
                    console.error('Error checking inbox:', error.message);
                }
            }, 5000);
        });
    }

    async checkInbox() {
        try {
            const response = await axios.get(`${this.baseUrl}/api/list`, {
                params: { recipient: this.recipient },
                headers: { ...this.headers, referer: `https://akunlama.com/inbox/${this.recipient}/list` }
            });
            return response.data;
        } catch (error) {
            console.error('Check inbox failed:', error.message);
            return [];
        }
    }

    async getMessageContent(msg) {
        try {
            const response = await axios.get(`${this.baseUrl}/api/getHtml`, {
                params: { region: msg.storage.region, key: msg.storage.key },
                headers: { ...this.headers, referer: `https://akunlama.com/inbox/${this.recipient}/message/${msg.storage.region}/${msg.storage.key}` }
            });
            return response.data;
        } catch (error) {
            console.error('Get message content failed:', error.message);
            return '';
        }
    }

    extractCode(html) {
        if (!html) return null;
        const match = html.match(/(\d{6})/);
        return match ? match[1] : null;
    }
}

async function main() {
    try {
        // Check command line arguments
        const args = process.argv.slice(2);
        const imagePath = args[0] || 'image.png';
        const prompt = args[1] || 'konser';
        
        console.log('Starting Nanana image processor');
        console.log(`Image path: ${imagePath}`);
        console.log(`Prompt: ${prompt}`);
        
        const scraper = new Nanana();
        
        console.log('Initializing...');
        await scraper.initialize();
        
        console.log('Processing image...');
        const result = await scraper.processImage(imagePath, prompt);
        
        console.log('Final result:');
        console.log(JSON.stringify(result, null, 2));
    } catch (error) {
        console.error('Main process failed:', error.message);
        process.exit(1);
    }
}

// Run the main function
if (require.main === module) {
    main();
}

module.exports = { Nanana, TempMailScraper };            if (sessionCookie) {
                this.sessionToken = sessionCookie.split(';')[0];
                this.cookieString = this.sessionToken;
            }
        }
        
        return response.data;
    }

    async uploadImage(imagePath) {
        const form = new FormData();
        form.append('image', fs.createReadStream(imagePath));

        const response = await axios.post(
            `${this.baseUrl}/api/upload-img`,
            form,
            {
                headers: {
                    ...this.defaultHeaders,
                    ...form.getHeaders(),
                    'Cookie': this.cookieString,
                    'x-fp-id': this.generateFpId()
                }
            }
        );

        return response.data;
    }

    generateFpId() {
        const random = crypto.randomBytes(32).toString('hex');
        const timestamp = Date.now().toString();
        return Buffer.from(random + timestamp).toString('base64').slice(0, 128);
    }

    async generateImage(imageUrl, prompt) {
        const response = await axios.post(
            `${this.baseUrl}/api/image-to-image`,
            { prompt, image_urls: [imageUrl] },
            {
                headers: {
                    ...this.defaultHeaders,
                    'content-type': 'application/json',
                    'Cookie': this.cookieString,
                    'x-fp-id': this.generateFpId()
                }
            }
        );

        return response.data;
    }

    async getResult(requestId) {
        const response = await axios.post(
            `${this.baseUrl}/api/get-result`,
            { requestId, type: 'image-to-image' },
            {
                headers: {
                    ...this.defaultHeaders,
                    'content-type': 'application/json',
                    'Cookie': this.cookieString,
                    'x-fp-id': this.generateFpId()
                }
            }
        );

        return response.data;
    }

    async processImage(imagePath, prompt) {
        const uploadResult = await this.uploadImage(imagePath);
        const generateResult = await this.generateImage(uploadResult.url, prompt);
        
        while (true) {
            const result = await this.getResult(generateResult.request_id);
            if (result.completed) {
                console.log(JSON.stringify(result, null, 2));
                return result;
            }
            await new Promise(resolve => setTimeout(resolve, 2000));
        }
    }
}

class TempMailScraper {
    constructor() {
        this.baseUrl = 'https://akunlama.com';
        this.headers = {
            'accept': 'application/json, text/plain, */*',
            'accept-language': 'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7',
            'referer': 'https://akunlama.com/',
            'sec-ch-ua': '"Not:A-Brand";v="99", "Google Chrome";v="145", "Chromium";v="145"',
            'sec-ch-ua-mobile': '?0',
            'sec-ch-ua-platform': '"Windows"',
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/145.0.0.0 Safari/537.36'
        };
        this.recipient = crypto.randomBytes(8).toString('hex').substring(0, 10);
        this.lastCount = 0;
    }

    async getEmail() {
    }

    async waitForCode() {
        return new Promise((resolve) => {
            const interval = setInterval(async () => {
                const inbox = await this.checkInbox();
                if (inbox.length > this.lastCount) {
                    for (const msg of inbox.slice(this.lastCount)) {
                        const html = await this.getMessageContent(msg);
                        const code = this.extractCode(html);
                        if (code) {
                            clearInterval(interval);
                            resolve(code);
                        }
                    }
                    this.lastCount = inbox.length;
                }
            }, 5000);
        });
    }

    async checkInbox() {
        const response = await axios.get(`${this.baseUrl}/api/list`, {
            params: { recipient: this.recipient },
            headers: { ...this.headers, referer: `https://akunlama.com/inbox/${this.recipient}/list` }
        });
        return response.data;
    }

    async getMessageContent(msg) {
        const response = await axios.get(`${this.baseUrl}/api/getHtml`, {
            params: { region: msg.storage.region, key: msg.storage.key },
            headers: { ...this.headers, referer: `https://akunlama.com/inbox/${this.recipient}/message/${msg.storage.region}/${msg.storage.key}` }
        });
        return response.data;
    }

    extractCode(html) {
        const match = html.match(/(\d{6})/);
        return match ? match[1] : null;
    }
}

(async () => {
    const scraper = new Nanana();
    await scraper.initialize();
    await scraper.processImage('image.png', 'konser');
})();        );

        return response.data;
    }

    generateFpId() {
        const random = crypto.randomBytes(32).toString('hex');
        const timestamp = Date.now().toString();
        return Buffer.from(random + timestamp).toString('base64').slice(0, 128);
    }

    async generateImage(imageUrl, prompt) {
        const response = await axios.post(
            `${this.baseUrl}/api/image-to-image`,
            { prompt, image_urls: [imageUrl] },
            {
                headers: {
                    ...this.defaultHeaders,
                    'content-type': 'application/json',
                    'Cookie': this.cookieString,
                    'x-fp-id': this.generateFpId()
                }
            }
        );

        return response.data;
    }

    async getResult(requestId) {
        const response = await axios.post(
            `${this.baseUrl}/api/get-result`,
            { requestId, type: 'image-to-image' },
            {
                headers: {
                    ...this.defaultHeaders,
                    'content-type': 'application/json',
                    'Cookie': this.cookieString,
                    'x-fp-id': this.generateFpId()
                }
            }
        );

        return response.data;
    }

    async processImage(imagePath, prompt) {
        const uploadResult = await this.uploadImage(imagePath);
        const generateResult = await this.generateImage(uploadResult.url, prompt);
        
        while (true) {
            const result = await this.getResult(generateResult.request_id);
            if (result.completed) {
                console.log(JSON.stringify(result, null, 2));
                return result;
            }
            await new Promise(resolve => setTimeout(resolve, 2000));
        }
    }
}

class TempMailScraper {
    constructor() {
        this.baseUrl = 'https://akunlama.com';
        this.headers = {
            'accept': 'application/json, text/plain, */*',
            'accept-language': 'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7',
            'referer': 'https://akunlama.com/',
            'sec-ch-ua': '"Not:A-Brand";v="99", "Google Chrome";v="145", "Chromium";v="145"',
            'sec-ch-ua-mobile': '?0',
            'sec-ch-ua-platform': '"Windows"',
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/145.0.0.0 Safari/537.36'
        };
        this.recipient = crypto.randomBytes(8).toString('hex').substring(0, 10);
        this.lastCount = 0;
    }

    async getEmail() {
    }

    async waitForCode() {
        return new Promise((resolve) => {
            const interval = setInterval(async () => {
                const inbox = await this.checkInbox();
                if (inbox.length > this.lastCount) {
                    for (const msg of inbox.slice(this.lastCount)) {
                        const html = await this.getMessageContent(msg);
                        const code = this.extractCode(html);
                        if (code) {
                            clearInterval(interval);
                            resolve(code);
                        }
                    }
                    this.lastCount = inbox.length;
                }
            }, 5000);
        });
    }

    async checkInbox() {
        const response = await axios.get(`${this.baseUrl}/api/list`, {
            params: { recipient: this.recipient },
            headers: { ...this.headers, referer: `https://akunlama.com/inbox/${this.recipient}/list` }
        });
        return response.data;
    }

    async getMessageContent(msg) {
        const response = await axios.get(`${this.baseUrl}/api/getHtml`, {
            params: { region: msg.storage.region, key: msg.storage.key },
            headers: { ...this.headers, referer: `https://akunlama.com/inbox/${this.recipient}/message/${msg.storage.region}/${msg.storage.key}` }
        });
        return response.data;
    }

    extractCode(html) {
        const match = html.match(/(\d{6})/);
        return match ? match[1] : null;
    }
}

(async () => {
    const scraper = new Nanana();
    await scraper.initialize();
    await scraper.processImage('image.png', 'konser');
})();
